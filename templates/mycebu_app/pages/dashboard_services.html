<style>
  /* CSS for the Spinner */
  .spinner {
    width: 24px;
    height: 24px;
    border: 3px solid #e6eef0;
    border-top-color: #0d9488; /* Teal color to match your theme */
    border-radius: 50%;
    animation: spin 0.8s linear infinite;
    display: inline-block;
    vertical-align: middle;
    margin-right: 8px;
  }
  @keyframes spin {
    to { transform: rotate(360deg); }
  }
</style>

<section class="dash-panel is-active" id="tab-services">
  <div class="detail-card" style="width:95%; margin:0 auto;"> 
    <div class="card-head" style="margin-bottom:18px;">
      <h3 class="card-title">Services</h3>
      <p class="muted">Search and start an application</p>
    </div>

    <div id="servicesCardArea" style="display:flex; gap:12px; align-items:center; margin-bottom:18px; width:100%;">
      <div style="flex:1; position:relative;">
        <input id="serviceSearch" type="search" placeholder="Search services (click to show all)" 
               style="width:100%; padding:16px 18px; border-radius:10px; border:1px solid #e6eef0; box-shadow:0 2px 6px rgba(2,6,23,0.04); font-size:1.05rem; height:52px;">
      </div>
      <button id="clearSearch" type="button" style="background:#fff; border:1px solid #e6eef0; padding:10px 14px; border-radius:8px; cursor:pointer;">Clear</button>
    </div>

    <div id="servicesLoading" style="display:none; text-align:center; padding:30px; color:#6b7280;">
      <div class="spinner"></div> Loading services...
    </div>

    <div id="servicesGrid" class="services-grid" style="width:100%; gap:12px; grid-template-columns:repeat(auto-fit,minmax(240px,1fr));">
    </div>

    <p id="noResults" class="muted" style="display:none; margin-top:12px;">No services found.</p>
  </div>
</section>

<script>
(function () {
  const searchInput = document.getElementById('serviceSearch');
  const servicesGrid = document.getElementById('servicesGrid');
  const noResults = document.getElementById('noResults');
  const loadingEl = document.getElementById('servicesLoading'); // New Element
  const clearBtn = document.getElementById('clearSearch');
  const cardArea = document.getElementById('servicesCardArea');

  let services = [];
  let hideTimer = null;
  let isFetching = false;

  // Helper to toggle loading state
  function toggleLoader(show) {
    if (show) {
      loadingEl.style.display = 'block';
      servicesGrid.style.display = 'none';
      noResults.style.display = 'none';
    } else {
      loadingEl.style.display = 'none';
    }
  }

  async function loadServices() {
    // If we already have data, don't fetch again, just return it
    if (services.length > 0) return services;
    
    // Prevent double fetching
    if (isFetching) return; 

    try {
      isFetching = true;
      toggleLoader(true); // Show loader immediately

      const res = await fetch('/api/services/', {cache: "no-cache"});
      const data = await res.json();
      services = data.services || [];
      
    } catch (err) {
      console.error('Failed to load services from API', err);
      services = [];
    } finally {
      isFetching = false;
      toggleLoader(false); // Hide loader when done
    }
    return services;
  }

  function renderServices(list) {
    servicesGrid.innerHTML = '';

    // If list is empty (and we are not loading)
    if (!list || list.length === 0) {
      servicesGrid.classList.remove('visible');
      servicesGrid.style.display = 'none';
      // Only show "No Results" if we are not currently loading
      if(!isFetching) noResults.style.display = 'block';
      return;
    }

    noResults.style.display = 'none';
    servicesGrid.style.display = 'grid';
    // Small delay to allow display:grid to apply before adding class for opacity transition
    requestAnimationFrame(() => servicesGrid.classList.add('visible'));

    list.forEach((s, idx) => {
      const item = document.createElement('div');
      item.className = 'service-item';
      
      const title = s.title || 'Untitled Service';
      const desc = s.description || '';
      const serviceId = s.id || ''; 

      item.innerHTML = `
        <div>
          <h4 style="margin:0 0 6px 0; font-size:1.05rem; color:#0f172a;">${escapeHtml(title)}</h4>
          <p class="muted" style="margin:0; color:#6b7280; font-size:0.95rem; display: -webkit-box; -webkit-line-clamp: 2; -webkit-box-orient: vertical; overflow: hidden;">${escapeHtml(desc)}</p>
        </div>
        <div style="margin-top:auto; display:flex; gap:8px; justify-content:flex-end;">
          <button class="btn-apply" data-id="${escapeAttr(serviceId)}">Apply</button>
        </div>
      `;
      servicesGrid.appendChild(item);

      // Cascade animation
      setTimeout(() => item.classList.add('visible'), 30 * idx);
    });

    // Re-attach event listeners for dynamic buttons
    Array.from(servicesGrid.querySelectorAll('.btn-apply')).forEach(btn => {
      btn.addEventListener('click', (e) => {
        const id = btn.dataset.id;
        if(id) {
            const applyUrl = `/apply/${encodeURIComponent(id)}/`;
            window.location.href = applyUrl;
        }
      });
    });
  }

  function filterAndRender(q) {
    const term = (q || '').trim().toLowerCase();
    if (!term) {
      renderServices(services);
      return;
    }
    const filtered = services.filter(s => {
      const hay = ((s.title||'') + ' ' + (s.description||'') + ' ' + (s.id||'')).toLowerCase();
      return hay.indexOf(term) !== -1;
    });
    renderServices(filtered);
  }

  async function showGrid() {
    // If services are empty, we need to load them
    if (!services.length) {
      // Load logic handles the loader display
      await loadServices(); 
      renderServices(services);
    } else {
      // If already loaded, just render immediately
      renderServices(services);
    }
  }

  function hideGridImmediate() {
    servicesGrid.classList.remove('visible');
    // Hide grid after transition
    setTimeout(() => {
      servicesGrid.innerHTML = '';
      servicesGrid.style.display = 'none';
      noResults.style.display = 'none';
      loadingEl.style.display = 'none'; // Ensure loader is hidden too
    }, 340);
  }

  function scheduleHide(delay = 300) {
    clearTimeout(hideTimer);
    hideTimer = setTimeout(() => {
      const isInputFocused = (document.activeElement === searchInput);
      const isOverCardArea = cardArea.matches(':hover');
      const isOverGrid = servicesGrid && servicesGrid.matches(':hover');
      if (!isInputFocused && !isOverCardArea && !isOverGrid) {
        hideGridImmediate();
      }
    }, delay);
  }

  function escapeHtml(str) {
    if (!str) return '';
    return String(str).replace(/[&<>"']/g, function (m) {
      return ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'}[m]);
    });
  }
  function escapeAttr(s){ return escapeHtml(s); }

  // --- Event Listeners ---

  searchInput.addEventListener('focus', () => {
    // Determine if we need to show loader or just grid
    showGrid();
  });

  searchInput.addEventListener('input', (e) => {
    filterAndRender(e.target.value);
  });

  clearBtn.addEventListener('click', () => {
    searchInput.value = '';
    filterAndRender('');
    searchInput.focus();
  });

  [cardArea, servicesGrid].forEach(el => {
    if (!el) return;
    el.addEventListener('mouseenter', () => {
      clearTimeout(hideTimer);
    });
    el.addEventListener('mouseleave', () => {
      scheduleHide(260);
    });
  });

  document.addEventListener('click', (e) => {
    const within = e.target === searchInput || cardArea.contains(e.target) || (servicesGrid && servicesGrid.contains(e.target));
    if (!within) scheduleHide(0);
  });

  searchInput.addEventListener('blur', () => {
    scheduleHide(260);
  });

})();
</script>